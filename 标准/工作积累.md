# 工作积累

## Mysql

### Mysql函数，查询一个{1，2，3}是否包含于{1，2，3，4，5}

19/11/01

CREATE DEFINER=`root`@`localhost` FUNCTION `inte_array`(setA varchar(255),setB varchar(255)) RETURNS int(1)

BEGIN

 DECLARE idx INT DEFAULT 0 ; -- B 集合单元索引 

  DECLARE len INT DEFAULT 0;-- B 集合表达式长度

  DECLARE llen INT DEFAULT 0;-- 最后检查位置

  DECLARE clen INT DEFAULT 0;-- 当前检查位置

  DECLARE tmpStr varchar(255);-- 临时检查数据集

  DECLARE curt varchar(255);-- B 当前检查的单元

  SET len = LENGTH(setB);

  WHILE idx < len DO

​    SET idx = idx + 1;

​    SET tmpStr = SUBSTRING_INDEX(setB,",",idx);

​    SET clen = LENGTH(tmpStr);

-- 获取当前 setB 中的单元

​    IF idx = 1 THEN SET curt = tmpStr;

​    ELSE SET curt = SUBSTRING(setB,llen+2,clen-llen-1);

​    END IF;

-- 检查是否存在于 setA 中

​    IF FIND_IN_SET(curt,setA) > 0 THEN RETURN 1;

​    END IF;

-- 当前检查终点与上次检查终点相同则跳出

​    IF clen <= llen THEN RETURN 0;

​    END IF;

 

​    SET llen = clen;

  END WHILE;

  RETURN 0;

END



## Git

### Git上传失败

1. RPC failed; curl 55 SSL_write() returned SYSCALL, errno = 10053

   (1) 文件上传过大导致，解决方案：

   ① [user]

   ② name = 王永禧

   ③ email = 1036684165@qq.com

   ④ [core]

   ⑤ autocrlf = false

   ⑥ excludesfile = 

   ⑦ preloadindex = true

   ⑧ fscache = true

   ⑨ [gc]

   ⑩ auto = 256

   ⑪ 

   ⑫ [http]

   ⑬ postBuffer = 524288000

   ⑭ sslVerify = false

   ⑮ 

   ⑯ [https]

   ⑰ postBuffer = 524288000

   ⑱ 

   ⑲ [sendpack]

   ⑳ sideband = false

2. 

   

## JAVA

### JAVA路径

####  根据项目绝对路径获取文件 ，webapp下的文件

request.getSession().getServletContext().getRealPath(”template“ + File.separator + "health_business3.jrxml"）

![image-20200204184435081](C:\Users\Kaiwx\AppData\Roaming\Typora\typora-user-images\image-20200204184435081.png)



### java I/O 流

#### 输出流，不需要输出到磁盘上，而是直接触发浏览器下载

1. 则可使用out = response.getOutStream();

   ![image-20200204185113519](C:\Users\Kaiwx\AppData\Roaming\Typora\typora-user-images\image-20200204185113519.png)

2. 



## Redis

#### 缓存穿透：

**定义:**缓存穿透是指查询一个数据库一定不存在的数据

**后果：**例如我们的数据表中主键是自增产生的，所有的主键值都大于0。此时如果用户传入的参数为-1，会是怎么样？这个-1，就是一定不存在的对象。程序就会每次都去查询数据库，而每次查询都是空，每次又都不会进行缓存。假如有人恶意攻击，就可以利用这个漏洞，对数据库造成压力，甚至压垮我们的数据库。

**解决方案：**如果从数据库查询的对象为空，也放入缓存，key为用户提交过来的主键值，value为null，只是设定的缓存过期时间较短，比如设置为60秒。这样下次用户再根据这个key查询redis缓存就可以查询到值了（当然值为null），从而保护我们的数据库免遭攻击。



#### **缓存雪崩**：

**定义:**缓存雪崩，是指在某一个时间段，缓存集中过期失效。

**后果：**在缓存集中失效的这个时间段对数据的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。

**解决方案：**为了避免缓存雪崩的发生，我们可以将缓存的数据设置不同的失效时间，这样就可以避免缓存数据在某个时间段集中失效。例如对于热门的数据（访问频率高的数据）可以缓存的时间长一些，对于冷门的数据可以缓存的时间段一些。甚至对于一些特别热门的数据可以设置永不过期。



#### 缓存击穿

**定义:**缓存击穿，是指一个key非常热点（例如双十一期间进行抢购的商品数据），在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存。

**后果：**直接请求到数据库上，就像在一个屏障上凿开了一个洞。

**解决方案：**我们同样可以将这些热点数据设置永不过期就可以解决缓存击穿的问题了。