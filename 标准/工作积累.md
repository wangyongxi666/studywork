

# 工作积累

## Mysql

### Mysql函数，查询一个{1，2，3}是否包含于{1，2，3，4，5}

19/11/01

CREATE DEFINER=`root`@`localhost` FUNCTION `inte_array`(setA varchar(255),setB varchar(255)) RETURNS int(1)

BEGIN

 DECLARE idx INT DEFAULT 0 ; -- B 集合单元索引 

  DECLARE len INT DEFAULT 0;-- B 集合表达式长度

  DECLARE llen INT DEFAULT 0;-- 最后检查位置

  DECLARE clen INT DEFAULT 0;-- 当前检查位置

  DECLARE tmpStr varchar(255);-- 临时检查数据集

  DECLARE curt varchar(255);-- B 当前检查的单元

  SET len = LENGTH(setB);

  WHILE idx < len DO

​    SET idx = idx + 1;

​    SET tmpStr = SUBSTRING_INDEX(setB,",",idx);

​    SET clen = LENGTH(tmpStr);

-- 获取当前 setB 中的单元

​    IF idx = 1 THEN SET curt = tmpStr;

​    ELSE SET curt = SUBSTRING(setB,llen+2,clen-llen-1);

​    END IF;

-- 检查是否存在于 setA 中

​    IF FIND_IN_SET(curt,setA) > 0 THEN RETURN 1;

​    END IF;

-- 当前检查终点与上次检查终点相同则跳出

​    IF clen <= llen THEN RETURN 0;

​    END IF;

 

​    SET llen = clen;

  END WHILE;

  RETURN 0;

END

### 更新数据时，让数据库帮我们更新时间

- 在创建字段语句中，加上on update
- 类上加@DynamicUpdate

### Mysql数据库字符集选择，utf8mb4好处：可以存入微信表情



## Git

### Git上传失败

1. RPC failed; curl 55 SSL_write() returned SYSCALL, errno = 10053

   (1) 文件上传过大导致，解决方案：

   ① [user]

   ② name = 王永禧

   ③ email = 1036684165@qq.com

   ④ [core]

   ⑤ autocrlf = false

   ⑥ excludesfile = 

   ⑦ preloadindex = true

   ⑧ fscache = true

   ⑨ [gc]

   ⑩ auto = 256

   ⑪ 

   ⑫ [http]

   ⑬ postBuffer = 524288000

   ⑭ sslVerify = false

   ⑮ 

   ⑯ [https]

   ⑰ postBuffer = 524288000

   ⑱ 

   ⑲ [sendpack]

   ⑳ sideband = false

2. 


## JAVA

### JAVA路径

####  根据项目绝对路径获取文件 ，webapp下的文件

request.getSession().getServletContext().getRealPath(”template“ + File.separator + "health_business3.jrxml"）

![image-20200204184435081](C:\Users\Kaiwx\AppData\Roaming\Typora\typora-user-images\image-20200204184435081.png)

#### 根据ClassPathResource（）获取resources路径下的文件

```
 new ClassPathResource("changgou.jks")
```



### I/O 流

#### 输出流，不需要输出到磁盘上，而是直接触发浏览器下载

1. 则可使用out = response.getOutStream();

   ![image-20200204185113519](C:\Users\Kaiwx\AppData\Roaming\Typora\typora-user-images\image-20200204185113519.png)


   ```
           String getRealPath(String path)  
   			 String b = context.getRealPath("/b.txt");//web目录下资源访问
   	         System.out.println(b);
   	
           String c = context.getRealPath("/WEB-INF/c.txt");//WEB-INF目录下的资源访问
           System.out.println(c);
   
           String a = context.getRealPath("/WEB-INF/classes/a.txt");//src目录下的资源访问
           System.out.println(a);
   ```

#### IO流读取中文文件，出现乱码

- io流创建时，默认编码为GBK，文档编码需要进行统一

#### 读写文件 io类

```
 //缓冲区大小
        byte[] b = new byte[1024];
        //使用RandomAccessFile访问文件
        RandomAccessFile raf_read = new RandomAccessFile(sourceFile, "r");
        //分块
        for(int i=0;i<chunkNum;i++){
            //创建分块文件
            File file = new File(chunkPath+i);
            boolean newFile = file.createNewFile();
            if(newFile){
                //向分块文件中写数据
                RandomAccessFile raf_write = new RandomAccessFile(file, "rw");
                int len = -1;
                while((len = raf_read.read(b))!=-1){
                    raf_write.write(b,0,len);
                    if(file.length()>chunkSize){
                        break;
                    }
                }
                raf_write.close();
            }
                }
    raf_read.close();
```

#### 文件分块

```
//测试文件分块方法
    @Test
    public void testChunk() throws IOException {
        File sourceFile = new File("F:/develop/ffmpeg/lucene.mp4");
//        File sourceFile = new File("d:/logo.png");
        String chunkPath = "F:/develop/ffmpeg/chunk/";
        File chunkFolder = new File(chunkPath);
        if(!chunkFolder.exists()){
            chunkFolder.mkdirs();
        }
        //分块大小
        long chunkSize = 1024*1024*1;
        //分块数量
        long chunkNum = (long) Math.ceil(sourceFile.length() * 1.0 / chunkSize );
        if(chunkNum<=0){
            chunkNum = 1;
        }
        //缓冲区大小
        byte[] b = new byte[1024];
        //使用RandomAccessFile访问文件
        RandomAccessFile raf_read = new RandomAccessFile(sourceFile, "r");
        //分块
        for(int i=0;i<chunkNum;i++){
            //创建分块文件
            File file = new File(chunkPath+i);
            boolean newFile = file.createNewFile();
            if(newFile){
                //向分块文件中写数据
                RandomAccessFile raf_write = new RandomAccessFile(file, "rw");
                int len = -1;
                while((len = raf_read.read(b))!=-1){
                    raf_write.write(b,0,len);
                    if(file.length()>chunkSize){
                        break;
                    }
                }
                raf_write.close();
            }

        }
        raf_read.close();

    }
```

#### 文件合并

```
//测试文件合并方法
@Test
public void testMerge() throws IOException {
    //块文件目录
    File chunkFolder = new File("F:/develop/ffmpeg/chunk/");
    //合并文件
    File mergeFile = new File("F:/develop/ffmpeg/lucene1.mp4");
    if(mergeFile.exists()){
        mergeFile.delete();
    }
    //创建新的合并文件
    mergeFile.createNewFile();
    //用于写文件
    RandomAccessFile raf_write = new RandomAccessFile(mergeFile, "rw");
    //指针指向文件顶端
    raf_write.seek(0);
    //缓冲区
    byte[] b = new byte[1024];
    //分块列表
    File[] fileArray = chunkFolder.listFiles();
    // 转成集合，便于排序
    List<File> fileList = new ArrayList<File>(Arrays.asList(fileArray));
    // 从小到大排序
    Collections.sort(fileList, new Comparator<File>() {
        @Override
        public int compare(File o1, File o2) {
            if (Integer.parseInt(o1.getName()) < Integer.parseInt(o2.getName())) {
                return -1;
            }
            return 1;
        }
    });
    //合并文件
    for(File chunkFile:fileList){
        RandomAccessFile raf_read = new RandomAccessFile(chunkFile,"rw");
        int len = -1;
        while((len=raf_read.read(b))!=-1){
            raf_write.write(b,0,len);

        }
        raf_read.close();
    }
    raf_write.close();

}
```

## Map

### map中判断是否包含某个值a

不需要循环map，加入a为map的key，直接map.get(a);  看是否有返回值value，有则map中包含a

### ImmutableMap 类型map

```
//定义异常类型  ImmutableMap 封装的参数不可更改，且线程安全 (只读)
private static ImmutableMap<Class<? extends Throwable>,ResultCode> exceptionMap;
//map 构建对象
protected static ImmutableMap.Builder<Class<? extends Throwable>,ResultCode> builder = ImmutableMap.builder();

//自定义错误代码
static{
  builder.put(HttpMessageNotReadableException.class,CommonCode.NOT_READ_PARAM);
}
//不可预知异常
@ExceptionHandler(Exception.class)
@ResponseBody
public ResponseResult catchExcetion(Exception excetion){

log.error("catch exception:{}" ,excetion.getMessage());

//自定义异常封装
if(exceptionMap == null){
builder.build();
}

ResultCode resultCode = exceptionMap.get(excetion.getClass());
if(resultCode != null){
return new ResponseResult(resultCode); 
}

return new ResponseResult(CommonCode.SERVER_ERROR);
}
```

## 反射

### 获取classpath根路径

```
String classpath = this.getClass().getResource("/").getPath();
configuration.setDirectoryForTemplateLoading(new File(classpath + "/templates/"));
```

## Servlet

### 读取web.xml文件中定义的context-param的值

```
getServletContext.getInitParamter();
```



## Request

### 获取项目路径

        String getRealPath(String path)  
    		 String b = context.getRealPath("/b.txt");//web目录下资源访问
             System.out.println(b);
    
        String c = context.getRealPath("/WEB-INF/c.txt");//WEB-INF目录下的资源访问
        System.out.println(c);
    
        String a = context.getRealPath("/WEB-INF/classes/a.txt");//src目录下的资源访问
        System.out.println(a);

### 在控制器没有传入request时，可以通过代码获得request对象

```
HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();
```

## Response

### 点击页面资源，以下载形式，不直接打开

1. 超链接指向的资源如果能够被浏览器解析，则在浏览器中展示，如果不能解析，则弹出下载提示框。不满足需求
2. 任何资源都必须弹出下载提示框
3. 使用响应头设置资源的打开方式：
  * content-disposition:attachment;filename=xxx

### 往页面响应数据

```
response.setContentType("application/json;charset=utf-8");
outputStream = response.getOutputStream(errorMessage.getBytes(),"utf-8");
```

```
//跳转登陆页面方法
private Mono<Void> toLoginPage(String loginUrl, ServerWebExchange exchange) {
  ServerHttpResponse response = exchange.getResponse();
  response.setStatusCode(HttpStatus.SEE_OTHER);//跳转代码,跳转页面必填
  response.getHeaders().set("Location",loginUrl);
  return response.setComplete();
}
```

```
 response.setStatusCode(HttpStatus.UNAUTHORIZED); // 没有访问权限
 return response.setComplete();
```

### 在控制器没有传入response时，可以通过代码获得response对象

```
HttpServletResponse response = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getResponse();
```

### 手动给前端返回信封类  RequestContext类 Zuul 自带,这样设置就直接返回给前端

```
RequestContext requestContext = RequestContext.getCurrentContext();
requestContext.setResponseStatusCode(200);// 设置响应状态码
ResponseResult unauthenticated = new ResponseResult(CommonCode.UNAUTHENTICATED);
String jsonString = JSON.toJSONString(unauthenticated);
requestContext.setResponseBody(jsonString);
requestContext.getResponse().setContentType("application/json;charset=UTF-8");
```

## Cookie

### 如果Cookie设置了域名 setDomain( )，则存入的cookie只有在访问相应域名的页面时，才能获取

- 比如（域名设置为localhost时，http://localhost:40400/auth/userlogin 的cookie只存在localhost访问的页面中）

  (域名设置为xuecheng.com http://www.xuecheng.com/openapi/auth/userlogin 接口存入的cookie只存在xuecheng.com中)

  设置域名时可以忽略 (www.)

  ```
  tokenValiditySeconds: 1200  #token存储到redis的过期时间
  clientId: XcWebApp
  clientSecret: XcWebApp
  cookieDomain: xuecheng.com
  cookieMaxAge: -1
  ```

  ```
  CookieUtil.addCookie(response,cookieDomain,"/","uid",access_token,cookieMaxAge,false);
  ```

### 删除Cookie方法

- 直接把Cookie的有效值设置为0



## Filter

- ### init方法中，FilterConfig 获取项目路径

  ```
  FilterConfig.getServletContext.getRealPath();
  ```

  

## MQ

### rabbitMq

#### 保证生产者消息不丢失

流程 ： 开启消息保护机制（confirm）消息会自动写入磁盘进行持久化 -》使用自定义消息发送方法进行消息发送 -》自定义方法中把消息和元数据存入redis中 -》实现confirm方法 -》当消息写入磁盘失败，则在confirn中把redis中的消息数据元数据取出再次进行发送 -》写入成功时在confirm方法中把redis中的消息数据和元数据删除

1.为交换机、队列、消息 进行持久化操作

```
public FanoutExchange EXCHANGE_ORDERTIMEOUT(){
  return new FanoutExchange(EXCHANGE_ORDERTIMEOUT,true,false);
}
public Exchange EX_BUYING_ADDPOINTUSER(){
    return ExchangeBuilder.directExchange(EX_BUYING_ADDPOINTUSER).durable(true).build();
}
@Bean(CG_BUYING_ADDPOINT)
    public Queue CG_BUYING_ADDPOINT(){
    return new Queue(CG_BUYING_ADDPOINT,true);
}
rabbitTemplate 模板对象对于消息是默认开启持久化
```

2.RabbitMQ数据保护机制  开启confirm机制 ...(畅购day16有)

开启监听服务的手动应答：消息发送时，消息服务器会存放一个id，在消息发送出去以后，监听服务监听到了就会应答，消息服务器就会把对应的消息数据删除，手动应答就是自定义监听方法，在监听到消息，并处理完所有业务逻辑之后，再应答消息服务器，进行消息的删除。

#### Rabbitmq 默认单线程，设置多线程（异步）的配置

customContainerFactory  bean的名称随意,把配置好的异步信息类注入到rb的注解中

```
@Bean("customContainerFactory")
public SimpleRabbitListenerContainerFactory containerFactory(SimpleRabbitListenerContainerFactoryConfigurer configurer, ConnectionFactory connectionFactory) {
    SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();
    factory.setConcurrentConsumers(DEFAULT_CONCURRENT);
    factory.setMaxConcurrentConsumers(DEFAULT_CONCURRENT);
    configurer.configure(factory, connectionFactory);
    return factory;
}
```

```
@RabbitListener(queues = "${xc-service-manage-media.mq.queue-media-video-processor}",containerFactory = "customContainerFactory")
```



## Redis

### 缓存穿透

**定义:**缓存穿透是指查询一个数据库一定不存在的数据

**后果：**例如我们的数据表中主键是自增产生的，所有的主键值都大于0。此时如果用户传入的参数为-1，会是怎么样？这个-1，就是一定不存在的对象。程序就会每次都去查询数据库，而每次查询都是空，每次又都不会进行缓存。假如有人恶意攻击，就可以利用这个漏洞，对数据库造成压力，甚至压垮我们的数据库。

**解决方案：**如果从数据库查询的对象为空，也放入缓存，key为用户提交过来的主键值，value为null，只是设定的缓存过期时间较短，比如设置为60秒。这样下次用户再根据这个key查询redis缓存就可以查询到值了（当然值为null），从而保护我们的数据库免遭攻击。



### **缓存雪崩**

**定义:**缓存雪崩，是指在某一个时间段，缓存集中过期失效。

**后果：**在缓存集中失效的这个时间段对数据的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。

**解决方案：**为了避免缓存雪崩的发生，我们可以将缓存的数据设置不同的失效时间，这样就可以避免缓存数据在某个时间段集中失效。例如对于热门的数据（访问频率高的数据）可以缓存的时间长一些，对于冷门的数据可以缓存的时间段一些。甚至对于一些特别热门的数据可以设置永不过期。



### 缓存击穿

**定义:**缓存击穿，是指一个key非常热点（例如双十一期间进行抢购的商品数据），在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存。

**后果：**直接请求到数据库上，就像在一个屏障上凿开了一个洞。

**解决方案：**我们同样可以将这些热点数据设置永不过期就可以解决缓存击穿的问题了。



### 每次减（加）一操作，能保证原子性

```
decrement()//减
increment()//加
```

### StringRedisTemplate

#### 获取数据的剩余过期时间（也可用于判断数据是否成功存入redis，返回0则存入失败）

```
stringRedisTemplate.getExpire(tokenRedisKey, TimeUnit.SECONDS);
```

逻辑复杂时, 使用Lua脚本编写redis操作，也能保证原子性

## Nginx

### 返回html页面没有加载样式

1. 检查代理样式的路径是否正确
2. 使用ssi注意 由于Nginx先请求cms的课程预览功能得到html页面，再解析页面中的ssi标签，这里必须保证cms页面预览返回的页面的Content-Type为text/html;charset=utf-8

```
response.setHeader("Content-type","text/html;charset=utf-8");
```

### 跨域问题处理

	#跨域处理
	location /static/plugins/ {  
	alias "D:/Program Files/Java/JavaApp/IDEA/idea-git/studyProject/xc/xc-ui-pc-static-						portal/plugins/";
	add_header Access-Control-Allow-Origin http://ucenter.xuecheng.com;  
	add_header Access-Control-Allow-Credentials true;  
	add_header Access-Control-Allow-Methods GET;
	} 

### 指定某个配置文件生效

- nginx -c 配置文件

```
/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf
```



## Spring Security

### 获取登陆用户的信息

```
User user = (User) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
```

```
public void getUser(Authentication authentication){....}
```

![img](https://img-blog.csdn.net/20180713000030712?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RvbmdndWFiYWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

### 设置在页面可以通过iframe访问受保护的页面，默认为不允许访问

```
<security:http auto-config="true" use-expressions="true">
    <security:headers>
        <!--设置在页面可以通过iframe访问受保护的页面，默认为不允许访问-->
        <security:frame-options policy="SAMEORIGIN"></security:frame-options>
    </security:headers>
</security:http>
```

### 配置SpringSecurity或Oauth2后，接口访问报 302 

- 配置文件WebSecurityConfig 没有对路径放行，或路径配置错误

![image-20200326132415578](C:\Users\Kaiwx\AppData\Roaming\Typora\typora-user-images\image-20200326132415578.png)

![](C:\Users\Kaiwx\AppData\Roaming\Typora\typora-user-images\image-20200326132434986.png)

## Oauth2认证	

### 获取令牌为 ：Basic ， 请求资源服务通过身份验证的token为：Bearer

1. 获取令牌的头信息是 Authorization：Basic WGNXZWJBcHA6WGNXZWJBcHA= WGNXZWJBcHA6WGNXZWJBcHA= 是用户名:密码的base64编码。
2. 请求服务资源携带的Http header 信息为 Authorization：Bearer 令牌（令牌为长Token）

### 服务间互相调用失败解决

1. Feign 远程调用没有携带header 中的token，应使用feign增强设置token

2. RestTemplate 远程调用没有携带header 中的token，应使用 一下方法 设置 HttpEntity 中的header工具

   ```
   restTemplate.exchange(dataUrl, HttpMethod.GET, new HttpEntity<MultiValueMap<String, String>>(body, headers), Map.class);
   ```

   

## MVC

### 返回值，直接返回视图名，404

- 直接写 “视图名”，解析器会直接找相对于类requestMapper下的视图文件，需要加上“/视图名”

### 形参获取头信息值

```
public void add(@RequestHeader(value = 'User-Agent') String user_agent);
```

@CookieValue("JESSIONID")

### 返回值为空时，不想返回NULL，可以给信封类全局变量设置默认值

```
private username = '';
```

### @RequestParam 加与不加

加了该参数不能不传，不传报错

### url后面？跟上的参数如何接收 

```
map：[http://localhost:9009/search?brand=手机
@RequestParam String brand
```

```
如果传多个，可以使用map封装（一定要加 @RequestParam）
@RequestParam Map map
```



## Spring Boot

### Spring Task

#### 串行执行和并行执行

- 默认任务就是串行任务

- 开启并行任务

  ```
  @Configuration
  @EnableScheduling //这里加了启动类就不用加了
  public class AsyncTaskConfig implements SchedulingConfigurer, AsyncConfigurer {
    //线程池线程数量
    private int corePoolSize = 5;
  
    @Bean
    public ThreadPoolTaskScheduler taskScheduler()
    {
      ThreadPoolTaskScheduler scheduler = new ThreadPoolTaskScheduler();
      scheduler.initialize();//初始化线程池
      scheduler.setPoolSize(corePoolSize);//线程池容量
      return scheduler;
    }
  
    @Override
    public Executor getAsyncExecutor() {
      Executor executor = taskScheduler();
      return executor;
    }
  
    @Override
    public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {
      return null;
    }
  
    @Override
    public void configureTasks(ScheduledTaskRegistrar scheduledTaskRegistrar) {
      scheduledTaskRegistrar.setTaskScheduler(taskScheduler());
    }
  }
  ```

## Spring Cloud 

### Feign

#### feign.codec.DecodeException: Type definition error

在我们使用springboot时，用restTemplate或者Feign时可能会出现这样的错误；因为feign是通过http请求访问服务的所可以不实现serializable接口；
出现错误的原因是没有空的构造器，加上空的构造器就KO了 (Feign接口返回值)。

#### 使用Feign时，实体类必须准备无参构造

#### 使用Feign时，将token令牌向下传递

```
public class FeignClientInterceptor implements RequestInterceptor {
    @Override
    public void apply(RequestTemplate requestTemplate) {

        try {
            //使用RequestContextHolder工具获取request相关变量
            ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
            if(attributes!=null){
                //取出request
                HttpServletRequest request = attributes.getRequest();
                Enumeration<String> headerNames = request.getHeaderNames();
                if (headerNames != null) {
                    while (headerNames.hasMoreElements()) {
                        String name = headerNames.nextElement();
                        String values = request.getHeader(name);
                        if(name.equals("authorization")){
                            //System.out.println("name="+name+"values="+values);
                            requestTemplate.header(name, values);
                        }

                    }
                }
            }

        }catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

- 调用方添加 配置

```
@Bean
public FeignClientInterceptor feignClientInterceptor(){
    return new FeignClientInterceptor();
}
```



### Zuul

#### 当controller类上没有配置RequestMapping或RequestMapping("/") 时

```
strip-prefix: false #true：代理转发时去掉前缀，false:代理转发时不去掉前缀
```

![image-20200326140120169](C:\Users\Kaiwx\AppData\Roaming\Typora\typora-user-images\image-20200326140120169.png)

#### 手动给前端返回信封类  RequestContext类 Zuul 自带,这样设置就直接返回给前端

```
  //拒绝访问
  private void access_denied(){
    //上下文对象
    RequestContext requestContext = RequestContext.getCurrentContext();
    requestContext.setSendZuulResponse(false);//拒绝访问
    //设置响应内容
    ResponseResult responseResult =new ResponseResult(CommonCode.UNAUTHENTICATED);
    String responseResultString = JSON.toJSONString(responseResult);
    requestContext.setResponseBody(responseResultString);
    //设置状态码
    requestContext.setResponseStatusCode(200);

    HttpServletResponse response = requestContext.getResponse();
    response.setContentType("application/json;charset=utf-8");
  }
```

#### 资源服务请求过滤，判断是否已经登陆（cookie中是否含有token）

```
//使用StringRedisTemplate查询key的有效期
@Service
public class AuthService {

    @Autowired
    StringRedisTemplate stringRedisTemplate;

    //查询身份令牌
    public String getTokenFromCookie(HttpServletRequest request){
        Map<String, String> cookieMap = CookieUtil.readCookie(request, "uid");
        String access_token = cookieMap.get("uid");
        if(StringUtils.isEmpty(access_token)){
            return null;
        }
        return access_token;
    }
    //从header中查询jwt令牌
    public String getJwtFromHeader(HttpServletRequest request){
        String authorization = request.getHeader("Authorization");
        if(StringUtils.isEmpty(authorization)){
            //拒绝访问
            return null;
        }
        if(!authorization.startsWith("Bearer ")){
            //拒绝访问
            return null;
        }
        return authorization;
    }

    //查询令牌的有效期
    public long getExpire(String access_token) {
        //token在redis中的key
        String key = "user_token:"+access_token;
        Long expire = stringRedisTemplate.getExpire(key);
        return expire;
    }
}
```

```
//网关身份校验
@Component
public class LoginFilter extends ZuulFilter {
    private static final Logger LOGG = LoggerFactory.getLogger(LoginFilter.class);

    @Autowired
    AuthService authService;
    @Override
    public String filterType() {
        //四种类型：pre、routing、post、error
        return "pre";
    }

    @Override
    public int filterOrder() {
        return 0;
    }

    @Override
    public boolean shouldFilter() {
        return true;
    }

    @Override
    public Object run() {
        //上下文对象
        RequestContext requestContext = RequestContext.getCurrentContext();
        //请求对象
        HttpServletRequest request = requestContext.getRequest();
        //查询身份令牌
        String access_token = authService.getTokenFromCookie(request);
        if(access_token == null){
            //拒绝访问
            access_denied();
        }
        //从redis中校验身份令牌是否过期
        long expire = authService.getExpire(access_token);
        if(expire<=0){
            //拒绝访问
            access_denied();
        }
        //查询jwt令牌
        String jwt = authService.getJwtFromHeader(request);
        if(jwt == null){
            //拒绝访问
            access_denied();
        }

        return null;
    }

    //拒绝访问
    private void access_denied(){
        //上下文对象
        RequestContext requestContext = RequestContext.getCurrentContext();
        requestContext.setSendZuulResponse(false);//拒绝访问
        //设置响应内容
        ResponseResult responseResult =new ResponseResult(CommonCode.UNAUTHENTICATED);
        String responseResultString = JSON.toJSONString(responseResult);
        requestContext.setResponseBody(responseResultString);
        //设置状态码
        requestContext.setResponseStatusCode(200);

        HttpServletResponse response = requestContext.getResponse();
        response.setContentType("application/json;charset=utf-8");
    }

}
```

#### Zuul 网关过滤时，增强request参数（比如header），添加参数，继续访问后续资源

```
//获取上下文对象
RequestContext requestContext = RequestContext.getCurrentContext();
//验证通过后 把jwtToken从redis中取出，并设置到Header中
String jwt_token = authService.saveJwtTokenToHeader(access_token, request);
requestContext.addZuulRequestHeader("Authorization","Bearer "+jwt_token);
```

## GateWay

#### 资源服务请求过滤，判断是否已经登陆（cookie中是否含有token）

```
@Component
public class AuthFilter implements GlobalFilter,Ordered{

  @Autowired
  private AuthService authService;

  private static String LOGIN_URL = "http://localhost:8001/api/oauth/toLogin";

  //过滤逻辑
  @Override
  public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
    ServerHttpRequest request = exchange.getRequest();
    ServerHttpResponse response = exchange.getResponse();

    //放行登陆请求
    String path = request.getURI().getPath();
    if(path.contains("api/oauth/login") || !UrlFilter.hasAuthorize(path)){
      return chain.filter(exchange);
    }

    //从cookie中获取jti，如果不存在，则跳转登陆页面
    String jti = authService.getJtiFromCookie(request);
    if(StringUtils.isEmpty(jti)){
//      response.setStatusCode(HttpStatus.UNAUTHORIZED);
//      return response.setComplete(); 

      //跳转登陆页面
      return this.toLoginPage(LOGIN_URL+"?FROM="+request.getURI(),exchange);
    }

    //从redis获取jwt的值，不存在，则跳转登陆页面
    String jwt = authService.getJwtFromRedis(jti);
    if(StringUtils.isEmpty(jwt)){
//      response.setStatusCode(HttpStatus.UNAUTHORIZED);
//      return response.setComplete();

      //跳转登陆页面
      return this.toLoginPage(LOGIN_URL+"?FROM="+request.getURI(),exchange);
    }

    //对当前对象进行增强，让他携带jwt
    request.mutate().header("Authorization","Bearer" + jwt);

    return chain.filter(exchange);
  }

  //跳转登陆页面方法
  private Mono<Void> toLoginPage(String loginUrl, ServerWebExchange exchange) {
    ServerHttpResponse response = exchange.getResponse();
    response.setStatusCode(HttpStatus.SEE_OTHER);//跳转代码
    response.getHeaders().set("Location",loginUrl);
    return response.setComplete();
  }

  //执行优先级
  @Override
  public int getOrder() {
    return 1;
  }
}
```

## Spring

### 前端date和后端date 格式不对应，转换方法

```
public class Date2LongSerializer extends JsonSerializer<Date> {

    @Override
    public void serialize(Date date, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException, JsonProcessingException {
        jsonGenerator.writeNumber(date.getTime() / 1000);
    }
}
```

```
/** 创建时间. */
@JsonSerialize(using = Date2LongSerializer.class)
private Date createTime;

/** 更新时间. */
@JsonSerialize(using = Date2LongSerializer.class)
private Date updateTime;
```

### 返回前端时，为null的值不返回

```
@JsonInclude(JsonInclude.Include.NON_NULL)
public class abc{}
```

或

```
jackson:
  default-property-inclusion: non_null
```



## Elasticsearch

### Elasticsearch 索引分词，搜索分词技巧

- 索引的时候，分词尽可能细（创建索引放入索引库，能够更详细匹配关键字）
- 搜索的时候，分词尽可能粗（搜索时，关键字如果匹配太精细，则会查找出太多无关数据）

```
"name": { "type": "text", 
            "analyzer":"ik_max_word", 
            "search_analyzer":"ik_smart" }
```

### elsticsearch集群 报错with the same id but is a different node instance

- 是因为复制虚拟机时，elsticsearch时，将elsticsearch文件夹下的data文件夹一并复制了。而在前面测试时，data文件夹下已经产生了data数据，于是报上面的错误。

- 解决办法：删除elsticsearch文件夹下的data文件夹下的节点数据




## 参考文档

### Cron 表达式

- Cron表达式是一个字符串，字符串分为七个部分，每一个域代表一个含义。
-  Cron表达式7个域格式为： 秒 分 小时 日 月 星期几 年 
- Cron表达式6个域格式为： 秒 分 小时 日 月 周

![image-20200328014629394](C:\Users\Kaiwx\AppData\Roaming\Typora\typora-user-images\image-20200328014629394.png)

使用说明：

```
通配符说明:
* 表示所有值. 例如:在分的字段上设置 "*",表示每一分钟都会触发。

? 表示不指定值。使用的场景为不需要关心当前设置这个字段的值。
例如:要在每月的10号触发一个操作，但不关心是周几，所以需要周位置的那个字段设置为"?" 具体设置为 0
0 0 10 * ?

- 表示区间。例如 在小时上设置 "10-12",表示 10,11,12点都会触发。

, 表示指定多个值，例如在周字段上设置 "MON,WED,FRI" 表示周一，周三和周五触发

/ 用于递增触发。如在秒上面设置"5/15" 表示从5秒开始，每增15秒触发(5,20,35,50)。 在月字段上设
置'1/3'所示每月1号开始，每隔三天触发一次。

L 表示最后的意思。在日字段设置上，表示当月的最后一天(依据当前月份，如果是二月还会依据是否是润年
[leap]), 在周字段上表示星期六，相当于"7"或"SAT"。如果在"L"前加上数字，则表示该数据的最后一
个。例如在周字段上设置"6L"这样的格式,则表示“本月最后一个星期五"

W 表示离指定日期的最近那个工作日(周一至周五). 例如在日字段上设置"15W"，表示离每月15号最近的那
个工作日触发。如果15号正好是周六，则找最近的周五(14号)触发, 如果15号是周未，则找最近的下周一
(16号)触发.如果15号正好在工作日(周一至周五)，则就在该天触发。如果指定格式为 "1W",它则表示每月
1号往后最近的工作日触发。如果1号正是周六，则将在3号下周一触发。(注，"W"前只能设置具体的数字,不
允许区间"-").

# 序号(表示每月的第几个周几)，例如在周字段上设置"6#3"表示在每月的第三个周六.注意如果指定"#5",
正好第五周没有周六，则不会触发该配置(用在母亲节和父亲节再合适不过了) ；
```

常用表达式

```
0 0 10,14,16 * * ? 每天上午10点，下午2点，4点
0 0/30 9-17 * * ? 朝九晚五工作时间内每半小时
0 0 12 ? * WED 表示每个星期三中午12点
"0 0 12 * * ?" 每天中午12点触发
"0 15 10 ? * *" 每天上午10:15触发
"0 15 10 * * ?" 每天上午10:15触发
"0 15 10 * * ? *" 每天上午10:15触发
"0 15 10 * * ? 2005" 2005年的每天上午10:15触发
"0 * 14 * * ?" 在每天下午2点到下午2:59期间的每1分钟触发
"0 0/5 14 * * ?" 在每天下午2点到下午2:55期间的每5分钟触发
"0 0/5 14,18 * * ?" 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发
"0 0-5 14 * * ?" 在每天下午2点到下午2:05期间的每1分钟触发
"0 10,44 14 ? 3 WED" 每年三月的星期三的下午2:10和2:44触发
"0 15 10 ? * MON-FRI" 周一至周五的上午10:15触发
"0 15 10 15 * ?" 每月15日上午10:15触发
"0 15 10 L * ?" 每月最后一日的上午10:15触发
"0 15 10 ? * 6L" 每月的最后一个星期五上午10:15触发
"0 15 10 ? * 6L 2002-2005" 2002年至2005年的每月的最后一个星期五上午10:15触发
"0 15 10 ? * 6#3" 每月的第三个星期五上午10:15触发
```



## 分布式解决方案

### 乐观锁（防止多线程下，同时操作同一条数据）

- 为行数据设置version参数，操作或查询数据前，先调用update方法，带着version更新数据，如果能匹配数据，version则加1，此时其他数据进入时，带上未新增的version则匹配不上数据，后续操作失败

  ```
  @Query("update XcTask t set t.version = :version+1  where t.id = :id and t.version = :version")
  public int updateTaskVersion(@Param(value = "id") String id,@Param(value = "version") int version);
  ```



## 工具

### 验证码

```
		int width = 100;
	    int height = 50;
	    
        //1.创建一对象，在内存中图片(验证码图片对象)
        BufferedImage image = new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB);


        //2.美化图片
        //2.1 填充背景色
        Graphics g = image.getGraphics();//画笔对象
        g.setColor(Color.PINK);//设置画笔颜色
        g.fillRect(0,0,width,height);
    
        //2.2画边框
        g.setColor(Color.BLUE);
        g.drawRect(0,0,width - 1,height - 1);
    
        String str = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghigklmnopqrstuvwxyz0123456789";
        //生成随机角标
        Random ran = new Random();
    
        for (int i = 1; i <= 4; i++) {
            int index = ran.nextInt(str.length());
            //获取字符
            char ch = str.charAt(index);//随机字符
            //2.3写验证码
            g.drawString(ch+"",width/5*i,height/2);
        }


        //2.4画干扰线
        g.setColor(Color.GREEN);
    
        //随机生成坐标点
    
        for (int i = 0; i < 10; i++) {
            int x1 = ran.nextInt(width);
            int x2 = ran.nextInt(width);
    
            int y1 = ran.nextInt(height);
            int y2 = ran.nextInt(height);
            g.drawLine(x1,y1,x2,y2);
        }


        //3.将图片输出到页面展示
        ImageIO.write(image,"jpg",response.getOutputStream());

```



### BeanUtils

#### 对象拷贝注意

```
BeanUtils.copyProperties(源对象,目标对象);
```

- 使用此util拷贝时，源对象为null的属性值也会拷贝到目标对象，所以拷贝代码应该放在前面，后续再进行赋值


### JSON

#### 实体类 -》json，某些字段不想被添加进去

```
@JSONField(serialize = false)
private int SCENE; // 可被过滤

@JSONField(serialize = false)
private final int SCENE; // 不能过滤
```

### 启动报无法找到主类解决方案

- **是因为jdk安装目录有空格，将%CLASSPATH%改为"%CLASSPATH%"即可解决**

### Logstash

#### TypeError: could not coerce Fixnum to class java.lang.String

- mysql.conf的配置文件密码后面是要加双引号的

#### java.sql.SQLException: Unknown system variable 'query_cache_size'

- MySQL Connector的jar包和数据库不匹配造成的

#### ES采用UTC 时区，比北京时间早8小时，所以ES读取数据时让最后更新时间加8小时

```
where timestamp > date_add(:sql_last_value,INTERVAL 8 HOUR)
```

#### 停止Logstash

- 删除Data/.lock文件

### ProcessBuilder 调用第三方程序的工具类

```
@Test
    public void testProcessBuilder(){
        ProcessBuilder processBuilder = new ProcessBuilder();
//       processBuilder.command("ping","127.0.0.1");
       processBuilder.command("ipconfig");
        //将标准输入流和错误输入流合并，通过标准输入流读取信息
        processBuilder.redirectErrorStream(true);
        try {
            //启动进程
            Process start = processBuilder.start();
            //获取输入流
            InputStream inputStream = start.getInputStream();
            //转成字符输入流
            InputStreamReader inputStreamReader = new InputStreamReader(inputStream,"gbk");

            int len = -1;
            char[] c = new char[1024];
            StringBuffer outputString = new StringBuffer();
            //读取进程输入流中的内容
            while ((len= inputStreamReader.read(c))!=-1) {
                String s = new String(c,0,len);
                outputString.append(s);
                System.out.print(s);
            }
            inputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    @Test
    public void testFFmpeg(){
        ProcessBuilder processBuilder = new ProcessBuilder();
        //定义命令内容
        List<String> command = new ArrayList<>();
        command.add("D:\\Program Files\\ffmpeg-20180227-fa0c9d6-win64-static\\bin\\ffmpeg.exe");
        command.add("-i");
        command.add("E:\\ffmpeg_test\\1.avi");
        command.add("-y");//覆盖输出文件
        command.add("-c:v");
        command.add("libx264");
        command.add("-s");
        command.add("1280x720");
        command.add("-pix_fmt");
        command.add("yuv420p");
        command.add("-b:a");
        command.add("63k");
        command.add("-b:v");
        command.add("753k");
        command.add("-r");
        command.add("18");
        command.add("E:\\ffmpeg_test\\1.mp4");
        processBuilder.command(command);
        //将标准输入流和错误输入流合并，通过标准输入流读取信息
        processBuilder.redirectErrorStream(true);
        try {
            //启动进程
            Process start = processBuilder.start();
            //获取输入流
            InputStream inputStream = start.getInputStream();
            //转成字符输入流
            InputStreamReader inputStreamReader = new InputStreamReader(inputStream,"gbk");
            int len = -1;
            char[] c = new char[1024];
            StringBuffer outputString = new StringBuffer();
            //读取进程输入流中的内容
            while ((len= inputStreamReader.read(c))!=-1) {
                String s = new String(c,0,len);
                outputString.append(s);
                System.out.print(s);
            }
            inputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
```

### ffmpeg

#### Error when loading first segment  、 Invalid data found when processing input

- m3u8中本地文件的路径写错了

### RestTemplate

#### 设置某些状态码、响应异常正常返回前端，后端不对其进行处理

```
//指定 restTemplate当遇到400或401响应时候也不要抛出异常，也要正常返回值
restTemplate.setErrorHandler(new DefaultResponseErrorHandler(){

  @Override
  public void handleError(ClientHttpResponse response) throws IOException {
    //当响应的值为400或401时候也要正常响应，不要抛出异常
    if(response.getRawStatusCode()!=400 && response.getRawStatusCode()!=401){
      super.handleError(response);
    }
  }
});
```





## 编程技巧

### 网络传输 ‘ + ’处理

通过 GET方式传值的时候，+号会被浏览器处理为空。。需要转换为%2b，如果前端传入+，后端接收为空格，则需要replace（“”，“+”）

### 比较两个带小数的金额是否相等，0.1 和 0.10 的情况

可以让两数相减，比如金额的数值，相减后小于0.01，则为相等，大于则不相等（由于金额数值最小值为0.01，不会出现0.009的情况）



### 类似京东导航栏上，查询条件的拼接

![image-20200223113813104](C:\Users\Kaiwx\AppData\Roaming\Typora\typora-user-images\image-20200223113813104.png)

- 可以使用前端拼接参数 -》后端使用map接收 -》后端遍历map-》把曾经点击过的参数重新拼接-》url返回前端或者直接跳转页面




### 数据库变化监听

- 使用starter-canal监听数据库变化 -》把变化的数据插入消息队列中（rm，am）-》在消息队列监听中把数据取出 ，拼接在访问url的参数上 -》使用nginx 把访问路径指向lua的一个脚本 -》脚本中把更新的数据更新到redis和nginx的二级缓存openresty中




### 登陆成功后，跳转到原本访问的地址

- 在登陆过滤器中，如果无权访问，则跳转到"http://lcoalhost:8001/api/oauth/toLogin?form="+request.getURI().getPath()  (引号中是登陆跳转页面，后面拼接的是原访问页面)


```
@RequestMapping("/toLogin")
public String toLogin(@RequestParam(value="from",required = false,defaultValue = "") String from, Model model){
  model.addAttribute("from",from);
  return "login";
}
```

- 跳转到login.html页面，获取到from的值，继续进行跳转




### 定时任务   +  redis  预防重复提交操作的方法

- 在操作资源中，增加redis，把该操作数据加入redis中，如果重复发送操作的数据在redis中已经存在，则不做操作，如果在redis中不存在，则进行操作 ，(可以建一张任务表，把该操作任务记录下来，然后redis与任务表进行双重把关，redis对并发防重，任务表对持久化防重)


### 定时操作过期业务(有期限)

- 使用死信队列，在订单添加时发送消息，设置失效时间（该时间为订单支付超时时间） -》使用监听服务对死信队列中的订单号进行操作处理


### 定时去做一些逻辑操作

1. 可以启用定时任务去轮询操作
2. 可以启用定时任务去往队列中塞消息，另一个服务监听到消息以后，再做出反应

### 显示当前时间是在哪个时间段中，并且按照时间段显示时间

![image-20200302201759423](C:\Users\Kaiwx\AppData\Roaming\Typora\typora-user-images\image-20200302201759423.png)

- 获取当天凌晨时间 -》 创建集合，保存每隔两个小时保存进集合 -》把当前时间传入后端进行判断 ,循环集合 -》  

  date < now < date + 2,则把date定义为当前时间,循环5次（加5次2小时）得到五个时间段

### 限流操作

- 以商品id和username作为key存入redis，并生成count，设置有效期（在某某时间内，某用户的下单次数限定）


### 隐藏重要接口

- 可以定义一个获取随机数接口（getToken：生成随机数存入redis并返回前端），前端在调用完getToken后得到随机数一并传入重要接口中，接口方法检测随机数在redis中是否存在

### 断点续传方案

- 在前端把视频文件分割成多个块，并生成md5值发送到服务器 -》服务器预留块检查接口（块路径 + 块下标） -》传入的块如果已存在则无需管理，不存在则调用上传接口 -》当所有块已经上传完毕后，进行合并-》根据合并file生成md5值，然后与前端传入的md5值比较，如果相等，则说明文件已完整上传（并且说明需要上传的就是这个文件）

```
/**
 * @ClassName MediaUploadServiceImpl
 * @Description (这里用一句话描述这个类的作用)
 * @Author YongXi.Wang
 * @Date  2020年03月22日 14:03
 * @Version 1.0.0
*/
@Service
public class MediaUploadServiceImpl implements MediaUploadService {

  @Autowired
  private MediaFileRepository mediaFileRepository;

  //上传文件根目录
  @Value("${xc-service-manage-media.upload-location}")
  private String uploadPath;

  /**
   * 根据文件md5得到文件路径
   * 规则：
   * 一级目录：md5的第一个字符
   * 二级目录：md5的第二个字符
   * 三级目录：md5
   * 文件名：md5+文件扩展名
   * @param fileMd5 文件md5值
   * @param fileExt 文件扩展名
   * @return 文件路径
   */
  @Override
  public ResponseResult register(String fileMd5, String fileName, Long fileSize, String mimetype, String fileExt) {

    //检查文件在磁盘是否存在
    String fileFolderPath = this.getFileFolderPath(fileMd5);
    String filePath = this.getFilePath(fileMd5, fileExt);

    File oldFile = new File(filePath);
    boolean existsFromDisk = oldFile.exists();

    //检查文件信息在mongodb中是否存在  id为fileMd5
    Optional<MediaFile> opt = mediaFileRepository.findById(fileMd5);

    if(existsFromDisk && opt.isPresent()){
      ExceptionCast.cast(MediaCode.UPLOAD_FILE_REGISTER_EXIST);
    }

    //检查文件目录是否存在 不存在则创建
    File fileFolder = new File(fileFolderPath);
    if(!fileFolder.exists()){
      fileFolder.mkdirs();
    }

    return new ResponseResult(CommonCode.SUCCESS);
  }

  @Override
  public CheckChunkResult checkchunk(String fileMd5, Integer chunk, Integer chunkSize) {

    //获取分块地址
    String chunkPath = this.getChunkPath(fileMd5);

    //获取块文件路径  路径 + 下标
    File chunkFile = new File(chunkPath + chunk);

    if(chunkFile.exists()){

      return new CheckChunkResult(CommonCode.SUCCESS, true);
    }else{

      return new CheckChunkResult(CommonCode.FAIL, false);
    }

  }

  @Override
  public ResponseResult uploadchunk(MultipartFile file, Integer chunk, String fileMd5) {

    InputStream inputStream = null;
    FileOutputStream fileOutputStream = null;

    try {
      //获取分块地址
      String chunkPath = this.getChunkPath(fileMd5);

      //获取块文件路径  路径 + 下标
      File chunkFile = new File(chunkPath + chunk);

      //如果不存在 则自动创建
      if(!chunkFile.exists()){
        chunkFile.createNewFile();
      }

      //如果存在 则写入文件内容
      inputStream = file.getInputStream();
      fileOutputStream = new FileOutputStream(chunkFile);

      IOUtils.copy(inputStream,fileOutputStream);
    } catch (IOException e) {
      e.printStackTrace();
    }finally {
      //关闭io流
      if(inputStream != null){
        try {
          inputStream.close();
        } catch (IOException e) {
          e.printStackTrace();
        }
      }
      if(fileOutputStream != null){
        try {
          fileOutputStream.close();
        } catch (IOException e) {
          e.printStackTrace();
        }
      }
    }

    return new ResponseResult(CommonCode.SUCCESS);
  }

  @Override
  public ResponseResult mergechunks(String fileMd5, String fileName, Long fileSize, String mimetype, String fileExt) {

    //获取块目录
    String chunkPath = this.getChunkPath(fileMd5);
    File fileDir = new File(chunkPath);
    //获取所有块文件
    File[] files = fileDir.listFiles();
    List fileList = new ArrayList(Arrays.asList(files));

    //获取已存在的合并后的块文件
    File mergeFile = new File(this.getFilePath(fileMd5,fileExt));

    //合并分块
    File newMergeFile = this.merge(fileList,mergeFile);
    if(newMergeFile == null){
      return new ResponseResult(MediaCode.MERGE_FILE_FAIL);
    }

    //校验md5值和前端传入的是否一致
    boolean b = this.checkMerageFile(mergeFile, fileMd5);

    //将文件信息保存到数据库
    MediaFile mediaFile = new MediaFile();
    mediaFile.setFileId(fileMd5);
    mediaFile.setFileName(fileMd5+"."+fileExt);
    mediaFile.setFileOriginalName(fileName);
    //文件路径保存相对路径
    mediaFile.setFilePath(this.getFileFolderRelativePath(fileMd5,fileExt));
    mediaFile.setFileSize(fileSize);
    mediaFile.setUploadTime(new Date());
    mediaFile.setMimeType(mimetype);
    mediaFile.setFileType(fileExt);
    //状态为上传成功
    mediaFile.setFileStatus("301002");
    MediaFile save = mediaFileRepository.save(mediaFile);

    return new ResponseResult(CommonCode.SUCCESS);
  }

  //校验合并文件的md5值和前端传入的是否一致
  private boolean checkMerageFile(File merageFile , String fileMd5){

    if(merageFile == null || StringUtils.isEmpty(fileMd5)){
      return false;
    }

    try {
      //生成合并文件的md5值
      FileInputStream fis = new FileInputStream(merageFile);
      String md5Hex = DigestUtils.md5Hex(fis);

      //比较
      if(fileMd5.equalsIgnoreCase(md5Hex)){
        return true;
      }
    } catch (IOException e) {
      e.printStackTrace();
      return false;
    }

    return false;
  }

  //合并块文件
  private File merge(List<File> fileList,File mergeFile){

    RandomAccessFile ran_write = null;

    try {

      //判断原文件是否存在 存在则删除 不存在则重新创建
      if(mergeFile.exists()){
        mergeFile.delete();
      }

      //创建空文件
      mergeFile.createNewFile();

      //给块文件排序
      Collections.sort(fileList, new Comparator<File>() {
        @Override
        public int compare(File o1, File o2) {
          if(Integer.parseInt(o1.getName()) > Integer.parseInt(o2.getName())){
            return 1;
          }
          return -1;
        }
      });

      //创建输出流
      ran_write = new RandomAccessFile(mergeFile,"rw");

      for (File file : fileList) {

        //创建输入对象
        RandomAccessFile ran_read = new RandomAccessFile(file,"r");

        //定义缓冲区
        byte[] bytes = new byte[1024];
        int len = -1;
        //边读边写
        while ((len = ran_read.read(bytes)) != -1){
          ran_write.write(bytes,0,len);
        }

        ran_read.close();
      }

      return mergeFile;

    } catch (IOException e) {
      e.printStackTrace();
    }finally {
      if(ran_write != null){
        try {
          ran_write.close();
        } catch (IOException e) {
          e.printStackTrace();
          return null;
        }
      }
    }

    return null;
  }

  //获取文件相对路径
  private String getFileFolderRelativePath(String fileMd5, String fileExt) {

    return fileMd5.substring(0,1) + File.separator + fileMd5.substring(1,2) +
            File.separator + fileMd5 +
            File.separator + fileMd5 + "." + fileExt;

  }

  //获取服务器文件目录 的路径
  private String getFileFolderPath(String fileMd5){
    return uploadPath + fileMd5.substring(0,1) + File.separator + fileMd5.substring(1,2) + File.separator + fileMd5 + File.separator;
  }

  //获取服务器文件 块目录 的路径
  private String getChunkPath(String fileMd5){
    return uploadPath + fileMd5.substring(0,1) +
            File.separator + fileMd5.substring(1,2) + File.separator + fileMd5 + File.separator + "chunk" + File.separator;
  }

  //获取服务器文件 路径
  private String getFilePath(String fileMd5,String fileExt){
    return this.getFileFolderPath(fileMd5) + fileMd5 + "." + fileExt;
  }
}
```

### 登出从Cookie和Redis清除token的方案

1. Cookie和Redis的有效时间一样长，则无需判断是否成功从redis中删除，因为当查询出cookie时，redis刚好失效，则会出误差。
2. Redis的有效时间比Cookie长（长10s），则需要判断是否从redis中删除成功（安全），如果cookie的值已经失效，redis还存活10s，也没关系，因为用户无法携带cookie中的token来访问，还是得重新登陆。

网关过滤资源访问请求，处理token方案

取出cookie的uid（token的短令牌），在网关过滤器中，根据短令牌从redis

### 如何保证幂等性

- 幂等性是指同一个操作无论请求多少次，其结果都相同。

1. 操作之前在业务方法进行判断如果执行过了就不再执行。
2. 缓存所有请求和处理的结果，已经处理的请求则直接返回结果。
3. 在数据库表中加一个状态字段（未处理，已处理），数据操作时判断未处理时再处理。





## 异常

### centOS进度条显示到满以后就一直卡住不动了

- 重启系统,在出现grub选择的时候,选中centos,按e,然后在kernel行上按e,修改参数,将quiet删除,回车确认,按b启动,看看什么地方过不去了


### Data truncation: Out of range value for column 'huid' at row 1

- 在数据库某表中字段 “huid” 为 int 类型

  程序代码中设置的”huid”值为1518753768709 ，超出了该字段所承载的范围，故报错。

  解决方法为 int 类型修改为bigint类型

### No EntityManager with actual transaction available for current thread - cannot reliably process 'XXX

- 由于增删改方法上面没有加开启事务，数据库操作方法或Service类上加@Transactional 即可



## 软件使用

### idea

#### 给配置文件的变量注入值

![image-20200317014523620](C:\Users\Kaiwx\AppData\Roaming\Typora\typora-user-images\image-20200317014523620.png)

![image-20200317014541423](C:\Users\Kaiwx\AppData\Roaming\Typora\typora-user-images\image-20200317014541423.png)



### Github

#### 修改github上 项目仓库类型的方法

- 项目根目录下创建.gitattributes  提交到远程仓库

- 内容为 ：*.js linguist-language=Java

  ![image-20200330124233050](C:\Users\Kaiwx\AppData\Roaming\Typora\typora-user-images\image-20200330124233050.png)



### Linux

#### 第一次安装卡住

1. 需要导入镜像

#### Ping不通外网

1. 修改网关,与本地相同(至少网段相同)

上传/下载文件  rz/sz 命令不能使用

```
yum install -y lrzsz
```

#### Ip配置标配

修改配置的目录

```
vim /etc/sysconfig/network-scripts/ifcfg-ens33
```

```
TYPE=Ethernet
PROXY_METHOD=none
BROWSER_ONLY=no
BOOTPROTO=static
DEFROUTE=yes
IPADDR=192.168.0.160
NETMASK=255.255.255.0
GATEWAY=192.168.0.2
DNS1=223.5.5.5
DNS2=8.8.8.8
IPV4_FAILURE_FATAL=no
IPV6INIT=yes
IPV6_AUTOCONF=yes
IPV6_DEFROUTE=yes
IPV6_FAILURE_FATAL=no
IPV6_ADDR_GEN_MODE=stable-privacy
NAME=ens33
UUID=b11d09ef-6bd1-4b21-99eb-46c44f823a36
DEVICE=ens33
ONBOOT=yes
IPV6_PRIVACY=no
```



### Docker

#### 配置阿里云镜像加速器

```
sudo mkdir -p /etc/docker
sudo tee /etc/docker/daemon.json <<-'EOF'
{
  "registry-mirrors": ["https://t3vb8anh.mirror.aliyuncs.com"]
}
EOF
sudo systemctl daemon-reload
sudo systemctl restart docker
```

```
"registry-mirrors": ["https://docker.mirrors.ustc.edu.cn"]
```

#### 配置完阿里镜像加速后还是慢

1. 执行sudo systemctl daemon-reload 加载配置文件
2. 重启docker执行sudo systemctl restart docker

#### 清理磁盘命令

-  查看磁盘使用情况。

  ```
  du -hs /var/lib/docker/
  ```

- 类似于Linux上的**df**命令，用于查看Docker的磁盘使用情况

  ```
  docker system df
  ```

- 可以用于清理磁盘，删除关闭的容器、无用的数据卷和网络，以及dangling镜像(即无tag的镜像)

  ```
  docker system prune
  ```

- 命令清理得更加彻底，可以将没有容器使用Docker镜像都删掉。注意，这两个命令会把你暂时关闭的容器，以及暂时没有用到的Docker镜像都删掉了…所以使用之前一定要想清楚.。我没用过，因为会清理 没有开启的 Docker 镜像。

  ```
  docker system prune -a
  ```

- `df`命令查看当前计算器磁盘空闲情况

  ```
  df -a
  ```

- 从挂载点目录下开始使用`du`命令查找出空间占用最大的文件

  ```
  du -sh *
  ```

#### docker 中使用nginx 容器无法启动（原来 nginx 容器启动成功了，但里面的nginx 服务不自己启动，要手动去启动

```
按照网上的教程，pull nignx 镜像，

执行： sudo docker run -it -p 80:80 nginx /bin/bash 

查看：sudo docker ps 

看到容器已经运行，端口正常

但在容器外浏览器访问如：localhost 显示无法访问。。。

试过n 种方法及排错，均没头绪

无奈就再次进入nginx 容器：sudo docker -it  容器ID /bin/bash 

进入容器执行 ：curl localhost  （没有 curl 命令， apt-get install ..） 同样获取不到！

执行 ps -aux|grep nginx （没有 ps 命令，apt-get install ...）

没有nginx 进程！！！（nginx 容器成功启动，但里面的nginx 服务没有自启动！！！）

查找nginx 启动文件位置，

执行：/etc/init.d/nginx start

执行： ps -aux|grep nginx （nginx 服务启动成功！！！）

谁能告诉我，nginx 容器启动成功了，但里面的nginx 服务不自己启动，非要手动去启动！！！
```

#### 使用Dockerfile创建镜像时，ADD后面最好加上-y，安装配置默认选择yes，因为用dockerfile安装插件时停下询问有可能会创建镜像失败

#### 迁移 /var/lib/docker 目录

- [https://blog.csdn.net/weixin_32820767/article/details/81196250](https://blog.csdn.net/weixin_32820767/article/details/81196250)

- #### 挂载目录下的文件（数据卷）在打包镜像的时候不会跟镜像一起打包(在不使用dockerfile的前提下)

#### com.spotify.docker.client.shaded.javax.ws.rs.ProcessingException: org. apach

- 关闭虚拟机/服务器的防火墙

#### 容器无法访问宿主机里面的地址（git、maven、私服）Failed to connect to 192.168.0.160 port 3000: Host is unreachable

1. 关闭防火墙

   ```bash
   systemctl stop firewalld
   ```

2. 在防火墙上开发指定端口

   ```bash
   firewall-cmd --zone=public --add-port=2181/tcp --permanent
   firewall-cmd --reload
   ```

#### 快捷命令

docker中 启动所有的容器命令

```
docker start $(docker ps -a | awk '{ print $1}' | tail -n +2)
```

docker中  关闭所有的容器命令

```
docker stop $(docker ps -a | awk '{ print $1}' | tail -n +2)
```

docker中 删除所有的容器命令

```
docker rm $(docker ps -a | awk '{ print $1}' | tail -n +2)
```

docker中  删除所有的镜像

```
docker rmi $(docker images | awk '{print $3}' |tail -n +2)
```

idea命令行测试dockerfile构建镜像

```
mvn clean package docker:build -DpushImage^X
```

### Jenkins

#### 使用Jenkins镜像如何查询自带的java目录

```
echo $JAVA_HOME
```

#### 线上下载jenkins

```
wget https://mirrors.tuna.tsinghua.edu.cn/jenkins/redhat-stable/jenkins-2.229.1-1.noarch.rpm
```

#### 插件下载慢

- 修改升级地址

  ```
   http://mirror.xmission.com/jenkins/updates/current/update-center.json
   https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json
   http://mirror.esuni.jp/jenkins/updates/update-center.json
   http://mirror.xmission.com/jenkins/updates/update-center.json
  ```

#### 问题集合

- [https://blog.csdn.net/alittleyatou/article/details/78344117](https://blog.csdn.net/alittleyatou/article/details/78344117)

#### 输入密码后，安装插件时显示：This Jenkins instance appears to be offline

修改内容同下

#### jenkins启动一直显示 Jenkins正在启动,请稍后

```
需要你进入jenkins的工作目录，打开

hudson.model.UpdateCenter.xml

把

http://updates.jenkins-ci.org/update-center.json

改成

http://mirror.xmission.com/jenkins/updates/update-center.json
```

#### 启动docker 的 Jenkins镜像 

- 设置容器开机自启

```
--restart=always
```

- docker run --name=jenkins -p 8888:8080 -p 50000:50000 -v /root/jenkins:/var/jenkins_home -v /var/run/docker.sock:/var/run/docker.sock  -v  /usr/local/maven:/usr/local/maven jenkinsci/blueocean

#### [touch: cannot touch ‘/var/jenkins_home/copy_reference_file.log’: Permission denied](https://www.cnblogs.com/jxlsblog/p/9876226.html)

```
chown -R 1000:1000 /home/docker/jenkins
```

#### Docker 镜像的Jenkins 不要用官方版本，已经不维护，用 jenkinsci/blueocean

#### 卸载jenkins

```
service jenkins stop
yum clean all
yum -y remove jenkins
rm -rf administrator/.Jenkins
rm -rf .jenkins
```

#### maven报错：Return code is: 501 , ReasonPhrase:HTTPS Required

```
  <!-- 中央仓库1 -->
        <mirror>
            <id>repo1</id>
            <mirrorOf>central</mirrorOf>
            <name>Human Readable Name for this Mirror.</name>
            <url>https://repo1.maven.org/maven2/</url>
        </mirror>

        <!-- 中央仓库2 -->
        <mirror>
            <id>repo2</id>
            <mirrorOf>central</mirrorOf>
            <name>Human Readable Name for this Mirror.</name>
            <url>https://repo2.maven.org/maven2/</url>
        </mirror>
```



### SecureCRT

#### 界面中文乱码

-  选项→会话选项，将外观中的字符编码集修改为UTF-8即可，其他终端程序同理

