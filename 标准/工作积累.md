# 工作积累

## Mysql

### Mysql函数，查询一个{1，2，3}是否包含于{1，2，3，4，5}

19/11/01

CREATE DEFINER=`root`@`localhost` FUNCTION `inte_array`(setA varchar(255),setB varchar(255)) RETURNS int(1)

BEGIN

 DECLARE idx INT DEFAULT 0 ; -- B 集合单元索引 

  DECLARE len INT DEFAULT 0;-- B 集合表达式长度

  DECLARE llen INT DEFAULT 0;-- 最后检查位置

  DECLARE clen INT DEFAULT 0;-- 当前检查位置

  DECLARE tmpStr varchar(255);-- 临时检查数据集

  DECLARE curt varchar(255);-- B 当前检查的单元

  SET len = LENGTH(setB);

  WHILE idx < len DO

​    SET idx = idx + 1;

​    SET tmpStr = SUBSTRING_INDEX(setB,",",idx);

​    SET clen = LENGTH(tmpStr);

-- 获取当前 setB 中的单元

​    IF idx = 1 THEN SET curt = tmpStr;

​    ELSE SET curt = SUBSTRING(setB,llen+2,clen-llen-1);

​    END IF;

-- 检查是否存在于 setA 中

​    IF FIND_IN_SET(curt,setA) > 0 THEN RETURN 1;

​    END IF;

-- 当前检查终点与上次检查终点相同则跳出

​    IF clen <= llen THEN RETURN 0;

​    END IF;

 

​    SET llen = clen;

  END WHILE;

  RETURN 0;

END

### 更新数据时，让数据库帮我们更新时间

- 在创建字段语句中，加上on update
- 类上加@DynamicUpdate

### Mysql数据库字符集选择，utf8mb4好处：可以存入微信表情



## Git

### Git上传失败

1. RPC failed; curl 55 SSL_write() returned SYSCALL, errno = 10053

   (1) 文件上传过大导致，解决方案：

   ① [user]

   ② name = 王永禧

   ③ email = 1036684165@qq.com

   ④ [core]

   ⑤ autocrlf = false

   ⑥ excludesfile = 

   ⑦ preloadindex = true

   ⑧ fscache = true

   ⑨ [gc]

   ⑩ auto = 256

   ⑪ 

   ⑫ [http]

   ⑬ postBuffer = 524288000

   ⑭ sslVerify = false

   ⑮ 

   ⑯ [https]

   ⑰ postBuffer = 524288000

   ⑱ 

   ⑲ [sendpack]

   ⑳ sideband = false

2. 


## JAVA

### JAVA路径

####  根据项目绝对路径获取文件 ，webapp下的文件

request.getSession().getServletContext().getRealPath(”template“ + File.separator + "health_business3.jrxml"）

![image-20200204184435081](C:\Users\Kaiwx\AppData\Roaming\Typora\typora-user-images\image-20200204184435081.png)



### I/O 流

#### 输出流，不需要输出到磁盘上，而是直接触发浏览器下载

1. 则可使用out = response.getOutStream();

   ![image-20200204185113519](C:\Users\Kaiwx\AppData\Roaming\Typora\typora-user-images\image-20200204185113519.png)


   ```
           String getRealPath(String path)  
   			 String b = context.getRealPath("/b.txt");//web目录下资源访问
   	         System.out.println(b);
   	
           String c = context.getRealPath("/WEB-INF/c.txt");//WEB-INF目录下的资源访问
           System.out.println(c);
   
           String a = context.getRealPath("/WEB-INF/classes/a.txt");//src目录下的资源访问
           System.out.println(a);
   ```

#### IO流读取中文文件，出现乱码

- io流创建时，默认编码为GBK，文档编码需要进行统一

### 比较两个带小数的金额是否相等，0.1 和 0.10 的情况

可以让两数相减，比如金额的数值，相减后小于0.01，则为相等，大于则不相等（由于金额数值最小值为0.01，不会出现0.009的情况）



## Servlet

### 读取web.xml文件中定义的context-param的值

```
getServletContext.getInitParamter();
```



## Request

### 获取项目路径

        String getRealPath(String path)  
    		 String b = context.getRealPath("/b.txt");//web目录下资源访问
             System.out.println(b);
    
        String c = context.getRealPath("/WEB-INF/c.txt");//WEB-INF目录下的资源访问
        System.out.println(c);
    
        String a = context.getRealPath("/WEB-INF/classes/a.txt");//src目录下的资源访问
        System.out.println(a);


## Response

### 点击页面资源，以下载形式，不直接打开

1. 超链接指向的资源如果能够被浏览器解析，则在浏览器中展示，如果不能解析，则弹出下载提示框。不满足需求
2. 任何资源都必须弹出下载提示框
3. 使用响应头设置资源的打开方式：
  * content-disposition:attachment;filename=xxx



## Filter

### init方法中，FilterConfig 获取项目路径

- ```
   FilterConfig.getServletContext.getRealPath();
   ```
## Redis

#### 缓存穿透

**定义:**缓存穿透是指查询一个数据库一定不存在的数据

**后果：**例如我们的数据表中主键是自增产生的，所有的主键值都大于0。此时如果用户传入的参数为-1，会是怎么样？这个-1，就是一定不存在的对象。程序就会每次都去查询数据库，而每次查询都是空，每次又都不会进行缓存。假如有人恶意攻击，就可以利用这个漏洞，对数据库造成压力，甚至压垮我们的数据库。

**解决方案：**如果从数据库查询的对象为空，也放入缓存，key为用户提交过来的主键值，value为null，只是设定的缓存过期时间较短，比如设置为60秒。这样下次用户再根据这个key查询redis缓存就可以查询到值了（当然值为null），从而保护我们的数据库免遭攻击。



#### **缓存雪崩**

**定义:**缓存雪崩，是指在某一个时间段，缓存集中过期失效。

**后果：**在缓存集中失效的这个时间段对数据的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。

**解决方案：**为了避免缓存雪崩的发生，我们可以将缓存的数据设置不同的失效时间，这样就可以避免缓存数据在某个时间段集中失效。例如对于热门的数据（访问频率高的数据）可以缓存的时间长一些，对于冷门的数据可以缓存的时间段一些。甚至对于一些特别热门的数据可以设置永不过期。



#### 缓存击穿

**定义:**缓存击穿，是指一个key非常热点（例如双十一期间进行抢购的商品数据），在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存。

**后果：**直接请求到数据库上，就像在一个屏障上凿开了一个洞。

**解决方案：**我们同样可以将这些热点数据设置永不过期就可以解决缓存击穿的问题了。



## 工具

### 验证码

```
		int width = 100;
	    int height = 50;
	    
        //1.创建一对象，在内存中图片(验证码图片对象)
        BufferedImage image = new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB);


        //2.美化图片
        //2.1 填充背景色
        Graphics g = image.getGraphics();//画笔对象
        g.setColor(Color.PINK);//设置画笔颜色
        g.fillRect(0,0,width,height);
    
        //2.2画边框
        g.setColor(Color.BLUE);
        g.drawRect(0,0,width - 1,height - 1);
    
        String str = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghigklmnopqrstuvwxyz0123456789";
        //生成随机角标
        Random ran = new Random();
    
        for (int i = 1; i <= 4; i++) {
            int index = ran.nextInt(str.length());
            //获取字符
            char ch = str.charAt(index);//随机字符
            //2.3写验证码
            g.drawString(ch+"",width/5*i,height/2);
        }


        //2.4画干扰线
        g.setColor(Color.GREEN);
    
        //随机生成坐标点
    
        for (int i = 0; i < 10; i++) {
            int x1 = ran.nextInt(width);
            int x2 = ran.nextInt(width);
    
            int y1 = ran.nextInt(height);
            int y2 = ran.nextInt(height);
            g.drawLine(x1,y1,x2,y2);
        }


        //3.将图片输出到页面展示
        ImageIO.write(image,"jpg",response.getOutputStream());

```



### 对象拷贝注意

```
BeanUtils.copyProperties(源对象,目标对象);
```

使用此util拷贝时，源对象为null的属性值也会拷贝到目标对象，所以拷贝代码应该放在前面，后续再进行赋值



## MVC

### 返回值，直接返回视图名，404

- 直接写 “视图名”，解析器会直接找相对于类requestMapper下的视图文件，需要加上“/视图名”

### 形参获取头信息值

```
public void add(@RequestHeader(value = 'User-Agent') String user_agent);
```

@CookieValue("JESSIONID")

### 返回值为空时，不想返回NULL，可以给信封类全局变量设置默认值



## Spring

### 前端date和后端date 格式不对应，转换方法

```
public class Date2LongSerializer extends JsonSerializer<Date> {

    @Override
    public void serialize(Date date, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException, JsonProcessingException {
        jsonGenerator.writeNumber(date.getTime() / 1000);
    }
}
```

```
/** 创建时间. */
@JsonSerialize(using = Date2LongSerializer.class)
private Date createTime;

/** 更新时间. */
@JsonSerialize(using = Date2LongSerializer.class)
private Date updateTime;
```



### 返回前端时，为null的值不返回

```
@JsonInclude(JsonInclude.Include.NON_NULL)
public class abc{}
```

或

```
jackson:
  default-property-inclusion: non_null
```